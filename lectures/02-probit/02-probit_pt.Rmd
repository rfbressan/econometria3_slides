---
title: "Econometria III"
subtitle: "Modelos de Escolha Qualitativa"
author: "Rafael Bressan"
date: "Esag </br> 08/03/2023"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [default, "../../css/scpo.css", "../../css/scpo-fonts.css"]
    nature:
      beforeInit: ["../../js/ru_xaringan.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
    includes:
      in_header: ["../../libs/partials/header.html"]
---

layout: true

<div class="my-footer"><img src="../../img/logo/UdescEsag.jpeg" style="height: 60px;"/></div> 

---

```{r setup, include=FALSE,warning=FALSE,message=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  dev = "svg",
  cache = TRUE,
  fig.align = "center"
  #fig.width = 11,
  #fig.height = 5
)

# define vars
om = par("mar")
lowtop = c(om[1],om[2],0.1,om[4])
library(dplyr)
library(ggplot2)
library(ROCR)
library(marginaleffects)
library(modelsummary)
library(kableExtra)
library(data.table)
```

# Onde estamos?


**Hoje**

1. Modelos de escolha qualitativa!

2. Um aplicativo legal! üòé


---

layout: false

class: separator, middle

# Modelos de Escolha Qualitativa

---

layout: true

<div class="my-footer"><img src="../../img/logo/UdescEsag.jpeg" style="height: 60px;"/></div> 

---

# Modelos de Escolha Qualitativa

.pull-left[

At√© agora, nossos modelos ficaram assim:

$$\begin{align}
y &= b_0 + b_1 x + e \\
e &\sim D\left(0,\sigma^2\right)
\end{align}$$

* A suposi√ß√£o de distribui√ß√£o em $e$:

* Em princ√≠pio implica que $y \in \mathbb{R}$.

* Resultados de testes, renda, taxas de criminalidade, etc. s√£o todos resultados cont√≠nuos. ‚úÖ
]

--

.pull-right[

Mas alguns resultados s√£o claramente bin√°rios (ou seja, `VERDADEIRO` ou `FALSO`):

* Ou voc√™ trabalha ou n√£o,

* Ou voc√™ tem filhos ou n√£o,

* Ou voc√™ comprou um produto ou n√£o,

* Voc√™ jogou uma moeda e saiu cara ou coroa.
]

---

# Resultados Bin√°rios

* Resultados restritos a `FALSO` vs `VERDADEIRO`, ou `0` vs `1`.

* Ter√≠amos $y \in \{0,1\}$.

* Nessas situa√ß√µes, estamos principalmente interessados em estimar a **probabilidade de resposta** ou a **probabilidade de sucesso**:

$$p(x) = \Pr(y=1 | x)$$
* como $p(x)$ muda quando mudamos $x$?

     >Se aumentarmos $x$ em uma unidade, como a probabilidade de $y=1$ mudaria?
     
---

# Lembrando o Experimento de Bernoulli

.pull-left[
Lembre-se da [Distribui√ß√£o de Bernoulli?](https://en.wikipedia.org/wiki/Bernoulli_distribution): Chamamos uma vari√°vel aleat√≥ria $y \in \{0,1\}$ tal que

$$\begin{align}
\Pr(y = 1) &= p \\
\Pr(y = 0) &= 1-p \\
p &\in[0,1]
\end{align}$$

uma vari√°vel aleat√≥ria de *Bernoulli*.
]

--

.pull-right[
Para n√≥s: *condicione* essas probabilidades em uma covariada $x$

$$\begin{align}
\Pr(y = 1 | X = x) &= p(x) \\
\Pr(y = 0 | X = x) &= 1-p(x) \\
p(x) &\in[0,1]
\end{align}$$

* Particularmente: *valor esperado* (ou seja, a m√©dia) de $Y$ dado $x$

$$
E[y | x] = 1 \times p(x) + 0 \times (1-p(x)) = p(x)
$$

* Muitas vezes modelamos **expectativas condicionais** üòâ
]
---

# O Modelo de Probabilidade Linear (MPL)

* A op√ß√£o mais simples. Modele a probabilidade de resposta como

$$
\Pr(y = 1 | x) = p(x) = \beta_0 + \beta_1 x_1 + \dots + \beta_K x_K
$$
* Interpreta√ß√£o: *uma mudan√ßa de 1 unidade em $x_1$, digamos, resulta em uma mudan√ßa de $\beta_1$ em $p(x)$.*

## Exemplo: Mroz (1987)

* Participa√ß√£o feminina no mercado de trabalho

* Como o status de `inlf` (*na for√ßa de trabalho*) depende da renda familiar da mulher solteira, sua educa√ß√£o, idade e n√∫mero de filhos pequenos?
---

# Mroz 1987

```{r,fig.height = 4}
data(mroz, package = "wooldridge")
plot(factor(inlf) ~ age, data = mroz, 
     ylevels = 2:1,
     ylab = "in labor force?")
```


---

# Rodando o MPL

.pull-left[
```{r}
LPM <- lm(inlf ~ nwifeinc + educ + exper + I(exper^2) + age +I(age^2) + kidslt6,
          data = mroz)
broom::tidy(LPM)
```
]

.pull-right[
* **id√™ntico** aos nossos modelos de regress√£o linear anteriores

* Apenas `inlf` assume somente dois valores, 0 ou 1.

* Resultados: se a renda da mulher solteira aumenta em 10 (ou seja, 10.000 USD), $p(x)$ cai em 0,034 (isso √© um efeito pequeno!),

* uma crian√ßa pequena adicional reduziria a probabilidade de trabalho em 0,26 (isso √© grande).

* At√© agora, tudo simples.Ô∏è]

---

# MPL: Prevendo probabilidades negativas?!


.pull-left[
```{r,echo = FALSE}
pr = predict(LPM)
plot(pr[order(pr)],ylab = "P(inlf = 1)")
abline(a = 0, b = 0, col = "red",lw = 3)
abline(a = 1, b = 0, col = "red",lw = 3)
```
]

.pull-right[
<br>
<br>
* As previs√µes do MPL de $p(x)$ n√£o s√£o garantidas no intervalo unit√°rio $[0,1]$.

* Lembre-se: $e \sim D\left(0,\sigma^2\right)$

* aqui, algumas probabilidades menores que zero!

* Particularmente irritante se voc√™ quiser *previs√µes*: O que √© probabilidade -0,3? ü§î]

---

# MPL no modelo saturado: sem problemas!

.left-wide[
```{r,message=FALSE,warning=FALSE}
mroz %<>% 
  # classify age into 3 and huswage into 2 classes
  mutate(age_fct = cut(age,breaks = 3,labels = FALSE),
         huswage_fct = cut(huswage, breaks = 2,labels = FALSE)) %>%
  mutate(classes = paste0("age_",age_fct,"_hus_",huswage_fct))

LPM_saturated = mroz %>%
  lm(inlf ~ classes, data = .)
broom::tidy(LPM_saturated)
```

]

.right-thin[
* *modelo saturado* : s√≥ tem vari√°veis explicativas bin√°rias (_dummies_)

* Cada classe: $p(x)$ *dentro daquela c√©lula*.

]

---

# MPL no modelo saturado: sem problemas!

.left-wide[
```{r saturated,message=FALSE,warning=FALSE,fig.height = 5,echo = FALSE}
mroz$pred <- predict(LPM_saturated)

ggplot(mroz[order(mroz$pred),], aes(x = 1:nrow(mroz),y = pred,color = classes)) + 
  geom_point() + 
  theme_bw() + 
  scale_y_continuous(limits = c(0,1), name = "p(inlf)")
```
]

.right-thin[

* Cada segmento de linha: $p(x)$ *dentro daquela c√©lula*.

* Por exemplo. as mulheres da faixa et√°ria mais jovem e de menor renda do marido (classe `age_1_hus_1`) t√™m a maior probabilidade de trabalhar (`r round(max(mroz$pred),3)`).
]


---

# Modelos de Resposta Bin√°ria N√£o-Lineares

Nesta classe de modelos mudamos a forma como modelamos a probabilidade de resposta $p(x)$. Em vez da estrutura linear simples de cima, escrevemos

$$
\Pr(y = 1 | x) = p(x) = G \left(\beta_0 + \beta_1 x_1 + \dots + \beta_K x_K \right)
$$
--

* ***quase*** id√™ntico ao MPL!

* exceto que o *√≠ndice linear* $\beta_0 + \beta_1 x_1 + \dots + \beta_K x_K$ agora est√° dentro da ***fun√ß√£o de liga√ß√£o*** $G(\cdot)$ (i.e. _link function_).

* Propriedade principal de $G$: transforma qualquer $z\in \mathbb{R}$ em um n√∫mero no intervalo $(0,1)$.

* Isso resolve nosso problema de previs√µes fora do intervalo $\left[0, 1\right]$ para probabilidades.
---

# Modelos de Resposta Bin√°ria N√£o-Lineares

## $G$: *probit* e *logit*

.left-wide[
```{r cdfs,echo = FALSE,fig.height = 4}
ggplot(data.frame(x = c(-5,5)), aes(x = x)) + 
  stat_function(fun = pnorm, aes(colour = "Probit"), size = 1) + 
  stat_function(fun = plogis, aes(colour = "Logit"), size = 1) + 
  theme_bw() + 
  scale_colour_manual(name = "Fun√ß√£o G",values = c("red", "blue")) +
  scale_y_continuous(name = "Pr(y = 1 | x)")
```
]

.right-thin[

<br>
Para **probit** e **logit**:

1. qualquer valor $x$ resulta em um valor $p(x)$ entre 0 e 1.

1. estritamente crescentes.

1. Logit tem *caudas mais longas*.

]

---

# Modelos de Resposta Bin√°ria N√£o-Lineares

## $G$: *probit* e *logit*

.left-wide[
```{r cdfs2, echo = FALSE,fig.height = 4}
ggplot(data.frame(x = c(-5,5)), aes(x = x)) + 
  stat_function(fun = pnorm, aes(colour = "Probit"), size = 1) + 
  stat_function(fun = plogis, aes(colour = "Logit"), size = 1) + 
  theme_bw() + 
  scale_colour_manual(name = "Fun√ß√£o G",values = c("red", "blue")) +
  scale_y_continuous(name = "Pr(y = 1 | x)")
```
]

.right-thin[

<br>
**Probit**:

* $G(z)=\Phi(z)$ Distribui√ß√£o Normal

**Logit**:

* $G(z)=\Lambda(z)=\frac{1}{1+\exp(-z)}$ Distribui√ß√£o Log√≠stica
]

---
# Modelos de Resposta Bin√°ria N√£o-Lineares

## Rodando probit e logit no `R`: a fun√ß√£o `glm`

* Usamos a fun√ß√£o `glm` para rodar um **modelo linear generalizado**

* Isso *generaliza* nosso modelo linear padr√£o. Temos que especificar uma `fam√≠lia` e um `link`:

```{r}
probit <- glm(inlf ~ age, 
                    data = mroz, 
                    family = binomial(link = "probit"))

logit <- glm(inlf ~ age, 
                    data = mroz, 
                    family = binomial(link = "logit"))

```

---

# Interpreta√ß√£o

.pull-left[
```{r}
modelsummary::modelsummary(list("probit" = probit,"logit" = logit))
```
]

.pull-right[
* coeficiente de probit para `idade` √© `r round(coef(probit)[2],3)`

* logit: `r round(coef(logit)[2],3)` para logit,

* impacto da idade na probabilidade de trabalhar √© **negativo**

* No entanto, **qu√£o** negativo? N√£o podemos dizer!]

---

# Interpreta√ß√£o

$$
\Pr(y = 1 | \text{age})= G \left(x \beta\right) = G \left(\beta_0 + \beta_1 \text{age} \right) 
$$
e o *efeito marginal* de `idade` na probabilidade de resposta √©

$$\frac{\partial{\Pr(y = 1 | \text{age})}}{ \partial{\text{age}}} = g \left(\beta_0 + \beta_1 \text{age} \right) \beta_1$$

* $g$ √© definida como $g(z) = \frac{dG}{dz}(z)$ - a primeira derivada de $G$ (sendo $G$ uma distribui√ß√£o, $g$ √© a fun√ß√£o densidade).

* dado que $G$ √© n√£o-linear, isso significa que $g$ n√£o ser√° constante. Voc√™ pode experimentar isso usando este [aplicativo aqui](https://floswald.shinyapps.io/marginal_effects_of_logit_probit/):


---

# Interpreta√ß√£o

***N√£o h√° um √∫nico efeito marginal*** nesses modelos, pois isso depende de *onde avaliamos* a express√£o anterior. Na pr√°tica, existem duas abordagens comuns:

1. reporte o **efeito parcial na m√©dia** (PEA): $$PEA(X_j)=g(\bar{x} \beta) \beta_j$$

1. relate o **efeito parcial m√©dio** (APE): $$APE(X_j)=\frac{1}{n} \sum_{i=1}^N g(x_i \beta) \beta_j$$

Felizmente, existem pacotes dispon√≠veis que nos ajudam a calcular esses efeitos marginais com bastante facilidade. Um deles se chama [`marginaleffects`](https://vincentarelbundock.github.io/marginaleffects/index.html), e o usamos da seguinte forma:

---

# Interpreta√ß√£o

```{r glms}
f <- "inlf ~ age + kidslt6 + nwifeinc" # setup a formula
glms <- list()
glms$probit <- glm(formula = f, 
                    data = mroz, 
                    family = binomial(link = "probit"))
glms$logit <- glm(formula = f, 
                    data = mroz, 
                    family = binomial(link = "logit"))
# now the marginal effects versions
mfx_mean <- lapply(glms, marginaleffects, newdata = "mean")
mfx_avg <- lapply(glms, marginaleffects)

```


---

# Interpreta√ß√£o

```{r, echo = FALSE}
modelsummary(c(mfx_mean, mfx_avg),
             output = "kableExtra",
             stars = TRUE,
             gof_omit = "AIC|BIC") |> 
    kable_classic() |> 
    add_header_above(c(" " = 1,
                       "PEA" = 2,
                       "APE" = 2))
```

---
layout: false
class: separator, middle


# Qualidade do Ajuste em Modelos Bin√°rios

---
layout: true

<div class="my-footer"><img src="../../img/logo/UdescEsag.jpeg" style="height: 60px;"/></div> 

---
# Qualidade do Ajuste em Modelos Bin√°rios

* N√£o existe $R^2$ universalmente aceito para modelos bin√°rios.

* Podemos pensar em um *pseudo* $R^2$ que compara nosso modelo com outro sem regressores:

```{r, eval=TRUE}
glms$probit0 <- update(glms$probit, formula = . ~ 1)
1 - as.vector(logLik(glms$probit)/logLik(glms$probit0))
```

--

* Mas isso n√£o √© super informativo (ao contr√°rio do $R^2$). As altera√ß√µes no valor da log-verossimilhan√ßa s√£o altamente n√£o lineares.

---
# Qualidade do Ajuste em Modelos Bin√°rios

* Vamos verificar **precis√£o** - qual √© a propor√ß√£o prevista corretamente! `round(fitted(x))` atribui `1` se a prob $> 0.5$ previsto.

```{r, echo=TRUE}
prop_tbl <- prop.table(table(true = mroz$inlf, 
                             pred = round(fitted(glms$probit)))) |> 
    as.data.table() |> 
    dcast(true~pred, value.var = "N")
kbl(prop_tbl, digits = 4,
    caption = "Matriz de Confus√£o") |> 
    add_header_above(c(" " = 1,
                       "Pred" = 2))
```

---

# Curvas ROC (Receiver Operating Characteristics)

```{r roc-names, echo=FALSE}
tp <- prop_tbl[2, 3]
fn <- prop_tbl[2, 2]
p <- tp + fn
tpr <- tp / p
fp <- prop_tbl[1, 3]
tn <- prop_tbl[1, 2]
n <- fp + tn
fpr <- fp / n

base_kbl <- kbl(prop_tbl, digits = 4) |> 
    add_header_above(c(" " = 1,
                       "Pred" = 2))
```

## [Nomenclatura](https://en.wikipedia.org/wiki/Receiver_operating_characteristic)

.pull-left[
**Taxa de Verdadeiros Positivos** (TPR, sensitividade, _recall_): $TP/P=$ `r tpr`  

**Taxa de Falsos Positivos** (FPR): $FP/N=$ `r fpr`

**Acur√°cia**: $(TP + TN)/ (P+N)=$ `r tp+tn`
]


.pull-right[

```{r panels, echo=FALSE}
xaringanExtra::use_panelset()
```

.panelset[
.panel[.panel-name[TPR]
```{r tpr, echo=FALSE}
base_kbl |>
    column_spec(2,
             bold = FALSE,
             background = ifelse(prop_tbl$`0` < 0.13, "darkgreen", "white"),
             color = ifelse(prop_tbl$`0` < 0.13, "white", "black")) |> 
    column_spec(3,
                bold = FALSE,
                background = ifelse(prop_tbl$`1` > 0.44, "darkgreen", "white"),
                color = ifelse(prop_tbl$`1` > 0.44, "white", "black"))
```

<br>
.center[Relacionado a **Poder**]
]

.panel[.panel-name[FPR]
```{r fpr, echo=FALSE}
base_kbl |>
    column_spec(2,
             bold = FALSE,
             background = ifelse(prop_tbl$`0` > 0.13, "darkgreen", "white"),
             color = ifelse(prop_tbl$`0` > 0.13, "white", "black")) |> 
    column_spec(3,
                bold = FALSE,
                background = ifelse(prop_tbl$`1` < 0.44, "darkgreen", "white"),
                color = ifelse(prop_tbl$`1` < 0.44, "white", "black"))

```

<br>
.center[Relacionado a **Erro Tipo I**]
]

.panel[.panel-name[ACC]
```{r acc, echo=FALSE}
base_kbl |>
    column_spec(2,
             bold = FALSE,
             background = ifelse(prop_tbl$`0` > 0.13, "darkgreen", "white"),
             color = ifelse(prop_tbl$`0` > 0.13, "white", "black")) |> 
    column_spec(3,
                bold = FALSE,
                background = ifelse(prop_tbl$`1` > 0.44, "darkgreen", "white"),
                color = ifelse(prop_tbl$`1` > 0.44, "white", "black"))
```
]

]
]

---

# Curvas ROC 

* O corte de 0,5 √© arbitr√°rio. E se todas as probabilidades previstas forem $> 0,5$, mas nos dados houver cerca de 50% de zeros?

* Vamos escolher um *corte arbitr√°rio* $c \in (0,1)$ e verificar a precis√£o de cada valor. Isso d√° uma vis√£o melhor.

---
# Curvas ROC


* Podemos confrontar a **taxa de verdadeiros positivos** (TPR) com a **taxa de falsos positivos** (FPR), para cada valor de corte $c\in[0, 1]$.

     1. TPR: n√∫mero de mulheres corretamente previstas para trabalhar dividido pelo n√∫mero de mulheres que trabalham.
     
     2. FPR: n√∫mero de mulheres incorretamente previstas para trabalhar dividido pelo n√∫mero de mulheres n√£o trabalhadoras.
    
--

* Plotar ***FPR vs TPR*** para cada $c$ define a curva **ROC**.

* Um bom modelo tem uma curva ROC no canto superior esquerdo: FPR = 0, TPR = 1.


---

# Curvas ROC 

.left-wide[
```{r,fig.height = 3}
pred_prob <- prediction(fitted(glms$probit), mroz$inlf)
par(mfrow = c(1,2), mar = lowtop)
acc <- ROCR::performance(pred_prob,"acc")
max_acc <- which.max(acc@y.values[[1]])
plot(acc)
points(acc@x.values[[1]][max_acc], acc@y.values[[1]][max_acc], col = "darkgreen")
roc <- ROCR::performance(pred_prob,"tpr","fpr")
plot(roc)
points(roc@x.values[[1]][max_acc], roc@y.values[[1]][max_acc], col = "darkgreen")
abline(0, 1, lty = 2, col = "red")
```
]

.right-thin[
<br>
<br>
* Melhor precis√£o em torno de $c=0,54$

* ROC sempre acima da linha de 45 graus. Melhor do que atribui√ß√£o aleat√≥ria (jogar uma moeda)!

]

---
# Estima√ß√£o de M√°xima Verossimilhan√ßa

* Ao inv√©s de usar m√©dia e vari√¢ncia condicionais, usaremos a distribui√ß√£o condicional completa

* Amostra *iid* $\lbrace y_i, x_i \rbrace_{i=1}^N$. Queremos estimar a distribui√ß√£o $f(y|x)$

* **Hip√≥tese:** esta distribui√ß√£o √© conhecida, a n√£o ser por um n√∫mero finito de par√¢metros fixos.
    + Impomos um modelo param√©trico para a densidade condicional
    
---

# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Probit

.pull-left[
* $y_i^*=x_i\theta + \varepsilon_i$, sendo $\varepsilon_i\sim N(0,1)$

* N√£o observamos $y_i^*$, apenas $y_i$
]

--

.pull-right[
$$\begin{equation*}
y_i = \begin{cases}
1 \text{ se } y_i^* > 0\\ 
0 \text{ se } y_i^* \leq 0
\end{cases}
\end{equation*}$$
]

---

# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Probit

* Dadas as especifica√ß√µes acima:

.pull-left[
$$\begin{align*}
P(y_i=1|x_i)&=P(y_i* > 0|x_i)\\
&=P(\varepsilon_i > -x_i\theta |x_i)\\
&=1-\Phi(-x_i\theta)\\
&=\Phi(x_i\theta)
\end{align*}$$
]
--
.pull-right[
$$\begin{align*}
P(y_i=0|x_i)&=P(y_i* \leq 0|x_i)\\
&=P(\varepsilon_i \leq -x_i\theta |x_i)\\
&=\Phi(-x_i\theta)\\
&=1-\Phi(x_i\theta)
\end{align*}$$
]

---
# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Probit

* A densidade condicional pode ser escrita como:

$$f(y_i|x_i)=\Phi(x_i\theta)^{y_i}\cdot [1-\Phi(x_i\theta)]^{1-y_i}$$
--

* Esta √© a probabilidade de ocorr√™ncia de um ponto $(x_i, y_i)$. Para o conjunto de dados observados temos a ***fun√ß√£o de verossimilhan√ßa***

$$\ell(\theta)=\Pi_{i=1}^N \Phi(x_i\theta)^{y_i}\cdot [1-\Phi(x_i\theta)]^{1-y_i}$$

--

* M√°xima Verossimilhan√ßa consiste em ***maximizar a fun√ß√£o de verossimilhan√ßa*** em rela√ß√£o aos par√¢metros, $\theta$.

* Podemos maximizar a ***log-verossimilhan√ßa*** por praticidade. $\mathcal{L}(\theta)=\log(\ell(\theta))=\sum_{i=1}^N y_i\log(\Phi(x_i\theta))+(1-y_i)\log(1-\Phi(x_i\theta))$

---
# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Probit

$$\hat\theta = \arg \max_{\theta} \mathcal{L}(\theta)$$

* O vetor de ***score*** √© dado pela derivada da log-verossimilhan√ßa em rela√ß√£o a cada um dos par√¢metros

$$s(\theta)=\nabla_\theta \mathcal{L}(\theta)=\left[\frac{\partial\mathcal{L}(\theta)}{\partial\theta_1}, \ldots, \frac{\partial\mathcal{L}(\theta)}{\partial\theta_k}\right]^{\prime}$$
* A Hessiana √© a matriz de segundas derivadas

$$H(\theta)=\nabla^2_\theta \mathcal{L}(\theta)$$

---
# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Probit

Exerc√≠cio: Calcule o _score_ do modelo probit.

R.: $$s(\theta)=\sum_{i}\frac{\phi(x_i\theta)}{\Phi(x_i\theta)[1-\Phi(x_i\theta)]}(y_i-\Phi(x_i\theta))x_i$$

---
# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Exponencial

- Suponha que tenhamos um conjunto simples de dados $\{x_i\}_{i=1}^N$ $iid$ e queremos ajustar uma distribui√ß√£o exponencial

--

- $x_i\sim Exp(\lambda)$. $f(x; \lambda)=\frac{1}{\lambda}e^{-x_i/\lambda}$. $x_i\geq 0$.

-- 

- Qual √© a fun√ß√£o de log-verossimilhan√ßa?
- Encontre o estimador de m√°xima verossimilhan√ßa $\hat\lambda_{mle}$

---

# Estima√ß√£o de M√°xima Verossimilhan√ßa

## Exemplo Exponencial

- Fun√ß√£o de verossimilhan√ßa: $L(\lambda)=\Pi_{i=1}^N f(x_i; \lambda)=\Pi_{i=1}^N \frac{1}{\lambda}e^{-x_i/\lambda}$

--

- Log-verossimilhan√ßa: $\mathcal{L}(\lambda)=\sum_{i=1}^N \log \frac{1}{\lambda}e^{-x_i/\lambda}$

--

- Ao final encontramos ...

.pull-left[
$$\hat\lambda_{mle}=\frac{1}{N}\sum_{i=1}^N x_i$$
]

.pull-right[
.center[
<img src="https://media.giphy.com/media/Jlirxn597uSeW7kPAQ/giphy.gif", height="250" />
]
]


---
# M√©todo dos Momentos Generalizado

## M√©todo dos Momentos (MM)

* Podemos utilizar momentos populacionais para identificar par√¢metros
    + $E[u_i]=0$ √© um exemplo
--
* De fato, ***tanto MQO quanto VI*** podem ser entendidos como estimadores MM!

* Quais s√£o os momentos utilizados no MQO?

--

* $E[u]=0$ e $E[xu]=0$, que s√£o as equa√ß√µes normais do MQO

* O MM resolve o an√°logo amostral destas equa√ß√µes

---

# M√©todo dos Momentos Generalizado

## M√©todo dos Momentos (MM)

.left-wide[

* Vamos considerar um _setup_ mais geral:
* $\theta_0\in\mathbb{R}^p$ √© um vetor dos par√¢metros da popula√ß√£o
* $m(\theta_0)\equiv E[g(Z_i, \theta_0)]=0$, s√£o as equa√ß√µes de momento
* $g(Z_i, \theta)$ √© uma fun√ß√£o vetorial $r\times 1$
* $Z_i\equiv (X_i, Y_i)$ √© uma observa√ß√£o do conjunto de dados 
* $\theta_0$ √© a √∫nica solu√ß√£o para a equa√ß√£o de momento
* MM vai resolver o an√°logo amostral:

$$\hat{m}(\hat\theta)=\frac{1}{N}\sum_{i=1}^N g(Z_i, \hat\theta)=0$$
]

--

.right-thin[
<!-- ![](https://media.giphy.com/media/ghuvaCOI6GOoTX0RmH/giphy.gif) -->
![](https://media.giphy.com/media/YmnRIWXjSkct9ZZtNZ/giphy.gif)
]
---

# M√©todo dos Momentos Generalizado

## Clarificando

.left-wide[
* Considere o MQO. Podemos escrever duas equa√ß√£o de momento que identificam os par√¢metros do modelo

$$\hat{m}(\hat\beta)=\begin{cases}
\frac{1}{N}\sum_{i=1}^N(y_i-\hat\beta_0-\hat\beta_1 x_i)=0\\
\frac{1}{N}\sum_{i=1}^Nx_i(y_i-\hat\beta_0-\hat\beta_1 x_i)=0
\end{cases}$$

* O MM escreve momentos populacionais em termos dos par√¢metros e resolve o sistema de equa√ß√µes, simples!
]
--

.right-thin[
.center[![](https://media.giphy.com/media/KU60D6Of7xb4qmFQwT/giphy.gif)]
]

---
# M√©todo dos Momentos Generalizado

## GMM

* Podemos generalizar o m√©todo dos momentos. Da√≠ o nome ***generalized method of moments*** - **GMM**

* Minimizar a norma ${\displaystyle \|{\hat {m}}(\theta )\|_{W}^{2}={\hat {m}}(\theta )^{\mathsf {T}}\,W{\hat {m}}(\theta)}$

* Onde $W$ √© uma matriz positiva definida

* ${\displaystyle {\hat {\theta }}=\operatorname {arg} \min _{\theta \in \Theta }{\bigg (}{\frac {1}{N}}\sum _{i=1}^{N}g(Z_{i},\theta ){\bigg )}^{\mathsf {T}}{W}{\bigg (}{\frac {1}{N}}\sum_{i=1}^{N}g(Z_{i},\theta ){\bigg )}}$

--
* Especialmente √∫til quando temos mais equa√ß√µes de momento do que par√¢metros

---
# M√©todo dos Momentos Generalizado

## Aplica√ß√µes de GMM

* MQO, VI e MLE podem ser obtidos a partir de um GMM

* Aplica√ß√µes diversas em
    + _Cross-Section_: modelos n√£o-lineares com vari√°veis end√≥genas 
    + S√©ries Temporais: correla√ß√£o serial e heterocedasticidade
    + Painel: extens√µes do modelo de efeitos fixos

* Veja mais em [Wooldridge (2001) JEP](https://pubs.aeaweb.org/doi/pdfplus/10.1257/jep.15.4.87)

---

# Leitura Recomendada

* WOOLDRIDGE, Jeffrey M. Introdu√ß√£o √† econometria: uma abordagem moderna. S√£o Paulo: Cengage Learning, 2016. Tradu√ß√£o da 4¬™ edi√ß√£o norte-americana por Jos√© Antonio Ferreira. Cap√≠tulo 17 Modelo com Vari√°veis Dependentes Limitadas e Corre√ß√µes da Sele√ß√£o Amostral.

* GUJARATI, Damodar N.; PORTER, Dawn C. Econometria b√°sica. Porto Alegre: Amgh Editora, 2011. - 5. ed. Cap√≠tulo 15 Modelos de regress√£o de resposta qualitativa

* WOOLDRIDGE, Jeffrey M. Econometric Analysis of Cross Section and Panel Data. MIT press, 2010. Second Edition. Chapter 15 Binary Response Models

---

layout: false

class: title-slide-final, middle
background-image: url(../../img/logo/UdescEsag.jpeg)
background-size: 350px
background-position: 9% 19%

# AT√â A PR√ìXIMA AULA!

Com a Lista 1 feita! `r emo::ji("white_check_mark")`

.footnote[
[1]: Este slides foram baseados nas aulas de econometria da [SciencesPo Department of Economics](https://github.com/ScPoEcon/ScPoEconometrics-Slides)
]


|                                                                                                            |                                   |
| :--------------------------------------------------------------------------------------------------------- | :-------------------------------- |
| <a href="https://github.com/rfbressan/econometria3_slides">.ScPored[<i class="fa fa-link fa-fw"></i>] | Slides |
| <a href="http://github.com/rfbressan">.ScPored[<i class="fa fa-github fa-fw"></i>]                          | @rfbressan                      |
| <a href="https://raw.githack.com/rfbressan/econometria3_slides/master/lectures/02-probit/lista_I_pt.html">.ScPored[<i class="fa fa-list fa-fw"></i>] | Lista de Exerc√≠cios I |

